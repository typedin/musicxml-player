import type { IMIDIConverter, MeasureTimemap } from './IMIDIConverter';
import { assertIsDefined, fetish, parseMusicXmlTimemap } from './helpers';
import pkg from '../package.json';
import { PlayerOptions } from './Player';

/**
 * Implementation of IMIDIConverter that simply fetches given MIDI file and timemap JSON file URIs.
 *
 * The timemap JSON file can be generated using the script midi-timemap which is distributed with musicxml-midi
 * @see https://github.com/infojunkie/musicxml-midi/blob/main/src/js/midi-timemap.js
 * ASSUMPTION The MIDI file is itself generated using musicxml-midi.
 *
 * The timemap JSON structure is simple enough to be generated by other tools as well.
 */
export class FetchConverter implements IMIDIConverter {
  protected _timemap?: MeasureTimemap;
  protected _midi?: ArrayBuffer;

  constructor(
    protected _midiOrUri: ArrayBuffer | string,
    protected _timemapOrUri?: MeasureTimemap | string,
  ) {}

  async initialize(musicXml: string, options: Required<PlayerOptions>): Promise<void> {
    this._midi =
      typeof this._midiOrUri === 'string'
        ? await (await fetish(this._midiOrUri)).arrayBuffer()
        : this._midiOrUri;
    this._timemap =
      typeof this._timemapOrUri === 'undefined'
        ? await parseMusicXmlTimemap(musicXml, options.timemapXslUri)
        : typeof this._timemapOrUri === 'string'
          ? <MeasureTimemap>await (await fetish(this._timemapOrUri)).json()
          : this._timemapOrUri;
  }

  get midi(): ArrayBuffer {
    assertIsDefined(this._midi);
    return this._midi;
  }

  get timemap(): MeasureTimemap {
    assertIsDefined(this._timemap);
    return this._timemap;
  }

  get version(): string {
    return `${pkg.name}/FetchConverter v${pkg.version}`;
  }
}
